---
layout: single
title:  "[UMC] 8ì£¼ì°¨ : Animation"
categories: UMC
tag: [UMC, project]
toc: true
author_profile: false
sidebar:
  nav: "docs"
search: true
---

## ğŸ“Â í•™ìŠµ ëª©í‘œ

---

1. HIG(Human InterfaceÂ Guidelines)ì— ë”°ë¥¸ ì• ë‹ˆë©”ì´ì…˜ì„ ì‚¬ìš©í•˜ëŠ” ì´ìœ ë¥¼ ì´í•´í•œë‹¤.
2. ì• ë‹ˆë©”ì´ì…˜ì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•œ 2ê°€ì§€ ë°©ë²•ì„ ì´í•´í•œë‹¤.
3. UIViewì˜ animate ë©”ì†Œë“œë¥¼ ì´í•´í•˜ê³  ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
4. Gestureë¥¼ ì´í•´í•˜ê³  ê¸°ëŠ¥ë“¤ì„ í™œìš©í•˜ì—¬ ì• ë‹ˆë©”ì´ì…˜ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

## âœğŸ»Â ìˆ˜ì—… ë‚´ìš© ì •ë¦¬

---

## ì• ë‹ˆë©”ì´ì…˜ ì‚¬ìš©í•˜ëŠ” ê²½ìš°

1. ì‹œìŠ¤í…œ ìƒíƒœë¥¼ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´
    
    <img width="1042" alt="1" src="https://user-images.githubusercontent.com/102133961/207801413-9793a498-9a14-4f29-883b-94c5dfbd50d7.png">

2. ë©”ë‰´ ë° ì „í™˜ì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´
    
    <img width="1315" alt="2" src="https://user-images.githubusercontent.com/102133961/207801423-f636328b-503a-41ee-a756-100074917d7b.png">

3. ì‹œê°ì ì¸ í”¼ë“œë°±ì„ ì£¼ê¸° ìœ„í•´
    
    <img width="696" alt="3" src="https://user-images.githubusercontent.com/102133961/207801440-c27c615c-2d54-44b5-9609-169178adf2d0.png">


## ì• ë‹ˆë©”ì´ì…˜ì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•œ 2ê°€ì§€ ë°©ë²•

1.UIViewì˜ animate í™œìš©í•˜ê¸°(IOS 4~)

2.Core Animation ì‚¬ìš©í•˜ê¸°(IOS 10~)

### Gesture

í„°ì¹˜ ì•¡ì…˜ì€ ë²„íŠ¼ìœ¼ë¡œë§Œ í•  ë¿ë§Œ ì•„ë‹ˆë¼ ì œìŠ¤ì³ë¥¼ í†µí•´ í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ ì±„íŒ… ëë‚˜ê³  í‚¤ë³´ë“œ ë‚´ë¦´ ë•Œ, ë¹ˆ í™”ë©´ í„°ì¹˜í•˜ëŠ” ê²½ìš°

ì•„ì´í° ë°°ê²½ì—ì„œ ì•„ë˜ë¡œ ìŠ¤ì™€ì´í”„í•˜ë©´ ê²€ìƒ‰ ëœ¨ëŠ” ê±°
<img width="969" alt="4" src="https://user-images.githubusercontent.com/102133961/207801471-0a0650b6-d3bc-4b6c-b18f-87febe8713ec.png">

<img width="1103" alt="5" src="https://user-images.githubusercontent.com/102133961/207801477-76233456-56fa-4585-8192-7c31d37a1dc6.png">


## ğŸ¯Â í•µì‹¬ í‚¤ì›Œë“œ

---

<aside>
ğŸ’¡ ì¤‘ìš”í•œ ê°œë…ë“¤ì— ëŒ€í•´ ì¡°ì‚¬í•´ì„œ ì •ë¦¬í•´ì£¼ì„¸ìš”!
ë ˆí¼ëŸ°ìŠ¤ë¥¼ ì°¸ê³ í•˜ì—¬ ê°œë…ì˜ ì •ì˜, ì†ì„±, ì¥ë‹¨ì  ë“±ì„ ì ì–´ì£¼ì…”ë„ ë©ë‹ˆë‹¤.
ì¡°ì‚¬ëŠ” ê³µì‹ í™ˆí˜ì´ì§€ **Best**, ë¸”ë¡œê·¸(ìµœì‹  ë‚ ì§œ) **Not Bad**

</aside>

- Animation
    
    # **animation(_:)**
    
    Applies the given animation to all animatable values within this view.
    
    iOS 13.0â€“15.0Â DeprecatediPadOS 13.0â€“15.0Â DeprecatedmacOS 10.15â€“12.0Â DeprecatedMac Catalyst 13.0â€“15.0Â DeprecatedtvOS 13.0â€“15.0Â DeprecatedwatchOS 6.0â€“8.0Â Deprecated
    
    **Deprecated**
    Use withAnimation or animation(_:value:) instead.
    
    ## **Declaration**
    
    `func animation(_ animation: [Animation](https://developer.apple.com/documentation/swiftui/animation)?) -> some [View](https://developer.apple.com/documentation/swiftui/view)`
    
    ## **Return Value**
    
    A view that wraps this view and appliesÂ `animation`Â to all animatable values used within the view.
    
    ****Parameters`animation`**The animation to apply to animatable values within this view.
    
    ## **Discussion**
    
    Use this modifier on leaf views rather than container views. The animation applies to all child views within this view; callingÂ `animation(_:)`Â on a container view can lead to unbounded scope.
    
- Gesture
    
    # **Gesture**
    
    An instance that matches a sequence of events to a gesture, and returns a stream of values for each of its states.
    
    iOS 13.0+iPadOS 13.0+macOS 10.15+Mac Catalyst 13.0+tvOS 13.0+watchOS 6.0+
    
    ## **Declaration**
    
    `protocol Gesture`
    
    ## **Overview**
    
    Create custom gestures by declaring types that conform to theÂ `Gesture`Â protocol.
    
    ## **Topics**
    
    ****Implementing a custom gesture****
    
    `[varÂ body:Â Self.Body](https://developer.apple.com/documentation/swiftui/gesture/body-swift.property)`
    
    The content and behavior of the gesture.
    
    **Required.**
    
    `[associatedtypeÂ BodyÂ :Â Gesture](https://developer.apple.com/documentation/swiftui/gesture/body-swift.associatedtype)`
    
    The type of gesture representing the body ofÂ `Self`.
    
    **Required.**
    
    ****Performing the gesture****
    
    `[funcÂ updating<State>(GestureState<State>,Â body: (Self.Value,Â inoutÂ State,Â inoutÂ Transaction) ->Â Void) ->Â GestureStateGesture<Self,Â State>](https://developer.apple.com/documentation/swiftui/gesture/updating(_:body:))`
    
    Updates the provided gesture state property as the gestureâ€™s value changes.
    
    `[funcÂ onChanged((Self.Value) ->Â Void) ->Â _ChangedGesture<Self>](https://developer.apple.com/documentation/swiftui/gesture/onchanged(_:))`
    
    Adds an action to perform when the gestureâ€™s value changes.
    
    Available whenÂ `Value`Â conforms toÂ `Equatable`.
    
    `[funcÂ onEnded((Self.Value) ->Â Void) ->Â _EndedGesture<Self>](https://developer.apple.com/documentation/swiftui/gesture/onended(_:))`
    
    Adds an action to perform when the gesture ends.
    
    `[associatedtypeÂ Value](https://developer.apple.com/documentation/swiftui/gesture/value)`
    
    The type representing the gestureâ€™s value.
    
    **Required.**
    
    ****Composing gestures****
    
    `[funcÂ simultaneously<Other>(with:Â Other) ->Â SimultaneousGesture<Self,Â Other>](https://developer.apple.com/documentation/swiftui/gesture/simultaneously(with:))`
    
    Combines a gesture with another gesture to create a new gesture that recognizes both gestures at the same time.
    
    `[funcÂ sequenced<Other>(before:Â Other) ->Â SequenceGesture<Self,Â Other>](https://developer.apple.com/documentation/swiftui/gesture/sequenced(before:))`
    
    Sequences a gesture with another one to create a new gesture, which results in the second gesture only receiving events after the first gesture succeeds.
    
    `[funcÂ exclusively<Other>(before:Â Other) ->Â ExclusiveGesture<Self,Â Other>](https://developer.apple.com/documentation/swiftui/gesture/exclusively(before:))`
    
    Combines two gestures exclusively to create a new gesture where only one gesture succeeds, giving precedence to the first gesture.
    
    ****Adding modifier keys to a gesture****
    
    `[funcÂ modifiers(EventModifiers) ->Â _ModifiersGesture<Self>](https://developer.apple.com/documentation/swiftui/gesture/modifiers(_:))`
    
    Combines a gesture with keyboard modifiers.
    
    ****Transforming a gesture****
    
    `[funcÂ map<T>((Self.Value) ->Â T) ->Â _MapGesture<Self,Â T>](https://developer.apple.com/documentation/swiftui/gesture/map(_:))`
    
    Returns a gesture thatâ€™s the result of mapping the given closure over the gesture.
    
    ## **Relationships**
    
    ****Conforming Types****
    
    - `[AnyGesture](https://developer.apple.com/documentation/swiftui/anygesture)`
    - `[DragGesture](https://developer.apple.com/documentation/swiftui/draggesture)`
    - `[ExclusiveGesture](https://developer.apple.com/documentation/swiftui/exclusivegesture)`
    - `[GestureStateGesture](https://developer.apple.com/documentation/swiftui/gesturestategesture)`
    - `[LongPressGesture](https://developer.apple.com/documentation/swiftui/longpressgesture)`
    - `[MagnificationGesture](https://developer.apple.com/documentation/swiftui/magnificationgesture)`
    - `[RotationGesture](https://developer.apple.com/documentation/swiftui/rotationgesture)`
    - `[SequenceGesture](https://developer.apple.com/documentation/swiftui/sequencegesture)`
    - `[SimultaneousGesture](https://developer.apple.com/documentation/swiftui/simultaneousgesture)`
    - `[SpatialTapGesture](https://developer.apple.com/documentation/swiftui/spatialtapgesture)`
    - `[TapGesture](https://developer.apple.com/documentation/swiftui/tapgesture)`
- UIGestureRecognizer
    
    # **UIGestureRecognizer**
    
    The base class for concrete gesture recognizers.
    
    iOS 3.2+iPadOS 3.2+Mac Catalyst 13.1+tvOS 9.0+
    
    ## **Declaration**
    
    `@MainActor class UIGestureRecognizer : [NSObject](https://developer.apple.com/documentation/objectivec/nsobject)`
    
    ## **Overview**
    
    AÂ *gesture recognizer*Â decouples the logic for recognizing a sequence of touches (or other input) and acting on that recognition. When one of these objects recognizes a common gesture or, in some cases, a change in the gesture, it sends an action message to each designated target object.
    
    The concrete subclasses ofÂ `UIGestureRecognizer`Â are the following:
    
    - `[UITapGestureRecognizer](https://developer.apple.com/documentation/uikit/uitapgesturerecognizer)`
    - `[UIPinchGestureRecognizer](https://developer.apple.com/documentation/uikit/uipinchgesturerecognizer)`
    - `[UIRotationGestureRecognizer](https://developer.apple.com/documentation/uikit/uirotationgesturerecognizer)`
    - `[UISwipeGestureRecognizer](https://developer.apple.com/documentation/uikit/uiswipegesturerecognizer)`
    - `[UIPanGestureRecognizer](https://developer.apple.com/documentation/uikit/uipangesturerecognizer)`
    - `[UIScreenEdgePanGestureRecognizer](https://developer.apple.com/documentation/uikit/uiscreenedgepangesturerecognizer)`
    - `[UILongPressGestureRecognizer](https://developer.apple.com/documentation/uikit/uilongpressgesturerecognizer)`
    - `[UIHoverGestureRecognizer](https://developer.apple.com/documentation/uikit/uihovergesturerecognizer)`
    
    TheÂ `UIGestureRecognizer`Â class defines a set of common behaviors that can be configured for all concrete gesture recognizers. It can also communicate with its delegate (an object that adopts theÂ `[UIGestureRecognizerDelegate](https://developer.apple.com/documentation/uikit/uigesturerecognizerdelegate)`Â protocol), thereby enabling finer-grained customization of some behaviors.
    
    A gesture recognizer operates on touches hit-tested to a specific view and all of that viewâ€™s subviews. It thus must be associated with that view. To make that association you must call theÂ `[UIView](https://developer.apple.com/documentation/uikit/uiview)`Â methodÂ `[addGestureRecognizer(_:)](https://developer.apple.com/documentation/uikit/uiview/1622496-addgesturerecognizer)`. A gesture recognizer doesnâ€™t participate in the viewâ€™s responder chain.
    
    A gesture recognizer has one or more target-action pairs associated with it. If there are multiple target-action pairs, theyâ€™re discrete, and not cumulative. Recognition of a gesture results in the dispatch of an action message to a target for each of the associated pairs. The action methods invoked must conform to one of the following signatures:
    
    `@IBAction func myActionMethod()@IBAction func myActionMethod(_ sender: UIGestureRecognizer)`
    
    Methods conforming to the latter signature permit the target in some cases to query the gesture recognizer sending the message for additional information. For example, the target could ask aÂ `[UIRotationGestureRecognizer](https://developer.apple.com/documentation/uikit/uirotationgesturerecognizer)`Â object for the angle of rotation (in radians) since the last invocation of the action method for this gesture. Clients of gesture recognizers can also ask for the location of a gesture by callingÂ `[location(in:)](https://developer.apple.com/documentation/uikit/uigesturerecognizer/1624219-location)`Â orÂ `[location(ofTouch:in:)](https://developer.apple.com/documentation/uikit/uigesturerecognizer/1624201-location)`.
    
    The gesture interpreted by a gesture recognizer can be either discrete or continuous. A discrete gesture, such as a double tap, occurs but once in a multi-touch sequence and results in a single action sent. However, when a gesture recognizer interprets a continuous gesture such as a rotation gesture, it sends an action message for each incremental change until the multi-touch sequence concludes.
    
    A window delivers touch events to a gesture recognizer before it delivers them to the hit-tested view attached to the gesture recognizer. Generally, if a gesture recognizer analyzes the stream of touches in a multi-touch sequence and doesnâ€™t recognize its gesture, the view receives the full complement of touches. If a gesture recognizer recognizes its gesture, the remaining touches for the view are canceled. The usual sequence of actions in gesture recognition follows a path determined by default values of theÂ `[cancelsTouchesInView](https://developer.apple.com/documentation/uikit/uigesturerecognizer/1624218-cancelstouchesinview)`,Â `[delaysTouchesBegan](https://developer.apple.com/documentation/uikit/uigesturerecognizer/1624234-delaystouchesbegan)`,Â `[delaysTouchesEnded](https://developer.apple.com/documentation/uikit/uigesturerecognizer/1624209-delaystouchesended)`Â properties:
    
    - `cancelsTouchesInView`Â â€” If a gesture recognizer recognizes its gesture, it unbinds the remaining touches of that gesture from their view (so the window wonâ€™t deliver them). The window cancels the previously delivered touches with a (`[touchesCancelled(_:with:)](https://developer.apple.com/documentation/uikit/uiresponder/1621116-touchescancelled)`) message. If a gesture recognizer doesnâ€™t recognize its gesture, the view receives all touches in the multi-touch sequence.
    - `delaysTouchesBegan`Â â€” As long as a gesture recognizer, when analyzing touch events, hasnâ€™t failed recognition of its gesture, the window withholds delivery of touch objects in theÂ `[UITouch.Phase.began](https://developer.apple.com/documentation/uikit/uitouch/phase/began)`Â phase to the attached view. If the gesture recognizer subsequently recognizes its gesture, the view doesnâ€™t receive these touch objects. If the gesture recognizer doesnâ€™t recognize its gesture, the window delivers these objects in an invocation of the viewâ€™sÂ `[touchesBegan(_:with:)](https://developer.apple.com/documentation/uikit/uiresponder/1621142-touchesbegan)`Â method (and possibly a follow-upÂ `[touchesMoved(_:with:)](https://developer.apple.com/documentation/uikit/uiresponder/1621107-touchesmoved)`Â invocation to inform it of the touches current location).
    - `delaysTouchesEnded`Â â€” As long as a gesture recognizer, when analyzing touch events, hasnâ€™t failed recognition of its gesture, the window withholds delivery of touch objects in theÂ `[UITouch.Phase.ended](https://developer.apple.com/documentation/uikit/uitouch/phase/ended)`Â phase to the attached view. If the gesture recognizer subsequently recognizes its gesture, the touches are canceled (in aÂ `[touchesCancelled(_:with:)](https://developer.apple.com/documentation/uikit/uiresponder/1621116-touchescancelled)`Â message). If the gesture recognizer doesnâ€™t recognize its gesture, the window delivers these objects in an invocation of the viewâ€™sÂ `[touchesEnded(_:with:)](https://developer.apple.com/documentation/uikit/uiresponder/1621084-touchesended)`Â method.
    
    Note that â€œrecognizeâ€ in the above descriptions doesnâ€™t necessarily equate to a transition to the Recognized state.
    
    ### **Subclassing notes**
    
    You may create a subclass ofÂ `UIGestureRecognizer`Â that recognizes a distinctive gesture â€” for example, a â€œcheck markâ€ gesture. If youâ€™re going to create such a concrete gesture recognizer, be sure to import theÂ `UIGestureRecognizerSubclass.h`Â header file (for Objective-C) or theÂ `UIKit.UIGestureRecognizerSubclass`Â module (for Swift). This file declares all the methods and properties a subclass must either override, call, or reset.
    
    Gesture recognizers operate within a predefined state machine, transitioning to subsequent states as they handle multi-touch events. The states and their possible transitions differ for continuous and discrete gestures. All gesture recognizers begin a multi-touch sequence in the Possible state (`[UIGestureRecognizer.State.possible](https://developer.apple.com/documentation/uikit/uigesturerecognizer/state/possible)`). Discrete gestures transition from Possible to either Recognized (`[recognized](https://developer.apple.com/documentation/uikit/uigesturerecognizer/state/1624228-recognized)`) or Failed (`[UIGestureRecognizer.State.failed](https://developer.apple.com/documentation/uikit/uigesturerecognizer/state/failed)`), depending on whether they successfully interpret the gesture or not. If the gesture recognizer transitions to Recognized, it sends its action message to its target.
    
    For continuous gestures, the state transitions a gesture recognizer might make are more numerous, as indicated in the following sequence:
    
    - Possible â€”> Began â€”> [Changed] â€”> Cancelled
    - Possible â€”> Began â€”> [Changed] â€”> Ended
    
    The Changed state is optional and may occur multiple times before the Cancelled or Ended state is reached. The gesture recognizer sends action messages at each state transition. Thus for a continuous gesture such as a pinch, action messages are sent as the two fingers move toward or away from each other. TheÂ `enum`Â constants representing these states are of typeÂ `[UIGestureRecognizer.State](https://developer.apple.com/documentation/uikit/uigesturerecognizer/state)`. (Note that the constants for Recognized and Ended states are synonymous.)
    
    Subclasses must set theÂ `[state](https://developer.apple.com/documentation/uikit/uigesturerecognizer/1619998-state)`Â property to the appropriate value when they transition between states.
    
    ### **Methods to override**
    
    The methods that subclasses must override are described inÂ [Implementing subclasses](https://developer.apple.com/documentation/uikit/uigesturerecognizer#1658520). Subclasses must also periodically reset theÂ `[state](https://developer.apple.com/documentation/uikit/uigesturerecognizer/1619998-state)`Â property (as described above) and may call theÂ `[ignore(_:for:)](https://developer.apple.com/documentation/uikit/uigesturerecognizer/1620010-ignore)`Â method.
    
    ### **Special considerations**
    
    TheÂ `[state](https://developer.apple.com/documentation/uikit/uigesturerecognizer/1619998-state)`Â property is declared inÂ `UIGestureRecognizer.h`Â as being read-only. This property declaration is intended for clients of gesture recognizers. Subclasses ofÂ `UIGestureRecognizer`Â must import theÂ `UIGestureRecognizerSubclass.h`Â header file (for Objective-C) or theÂ `UIKit.UIGestureRecognizerSubclass`Â module (for Swift). This file contains a redeclaration ofÂ `state`Â that makes it read-write.
    
- layoutIfNeeded()
    
    # **layoutIfNeeded()**
    
    Recalculate the receiverâ€™s layout, if required.
    
    iOS 2.0+iPadOS 2.0+macOS 10.5+Mac Catalyst 13.0+tvOS 9.0+
    
    ## **Declaration**
    
    `func layoutIfNeeded()`
    
    ## **Discussion**
    
    When this message is received, the layerâ€™s super layers are traversed until a ancestor layer is found that does not require layout. Then layout is performed on the entire layer-tree beneath that ancestor.
    
    ## **See Also**
    
    ****Managing Layer Resizing and Layout****
    
    `[varÂ layoutManager: CALayoutManager?](https://developer.apple.com/documentation/quartzcore/calayer/1410749-layoutmanager)`
    
    The object responsible for laying out the layerâ€™s sublayers.
    
    `[funcÂ setNeedsLayout()](https://developer.apple.com/documentation/quartzcore/calayer/1410946-setneedslayout)`
    
    Invalidates the layerâ€™s layout and marks it as needing an update.
    
    `[funcÂ layoutSublayers()](https://developer.apple.com/documentation/quartzcore/calayer/1410935-layoutsublayers)`
    
    Tells the layer to update its layout.
    
    `[funcÂ needsLayout() -> Bool](https://developer.apple.com/documentation/quartzcore/calayer/1410956-needslayout)`
    
    Returns a Boolean indicating whether the layer has been marked as needing a layout update.
    
    `[varÂ autoresizingMask: CAAutoresizingMask](https://developer.apple.com/documentation/quartzcore/calayer/1410877-autoresizingmask)`
    
    A bitmask defining how the layer is resized when the bounds of its superlayer changes.
    
    `[funcÂ resize(withOldSuperlayerSize: CGSize)](https://developer.apple.com/documentation/quartzcore/calayer/1410894-resize)`
    
    Informs the receiver that the size of its superlayer changed.
    
    `[funcÂ resizeSublayers(withOldSize: CGSize)](https://developer.apple.com/documentation/quartzcore/calayer/1410929-resizesublayers)`
    
    Informs the receiverâ€™s sublayers that the receiverâ€™s size has changed.
    
    `[funcÂ preferredFrameSize() -> CGSize](https://developer.apple.com/documentation/quartzcore/calayer/1410980-preferredframesize)`
    
    Returns the preferred size of the layer in the coordinate space of its superlayer.
    
- addTarget
    
    # **addTarget(_:action:for:)**
    
    AppIntentsUIKitiOS 16.0+iPadOS 16.0+macOS 13.0+Mac Catalyst 16.0+tvOS 16.0+watchOS 9.0+
    
    ## **Declaration**
    
    `override final func addTarget(
        _ target: Any?,
        action: [Selector](https://developer.apple.com/documentation/objectivec/selector),
        for controlEvents: [UIControl](https://developer.apple.com/documentation/uikit/uicontrol).[Event](https://developer.apple.com/documentation/uikit/uicontrol/event)
    )`
    
    - dictionary
        
        # **Dictionary**
        
        A collection whose elements are key-value pairs.
        
        iOS 8.0+iPadOS 8.0+macOS 10.10+Mac Catalyst 13.0+tvOS 9.0+watchOS 2.0+
        
        ## **Declaration**
        
        `@frozen struct Dictionary<Key, Value> where Key : [Hashable](https://developer.apple.com/documentation/swift/hashable)`
        
        ## **Overview**
        
        A dictionary is a type of hash table, providing fast access to the entries it contains. Each entry in the table is identified using its key, which is a hashable type such as a string or number. You use that key to retrieve the corresponding value, which can be any object. In other languages, similar data types are known as hashes or associated arrays.
        
        Create a new dictionary by using a dictionary literal. A dictionary literal is a comma-separated list of key-value pairs, in which a colon separates each key from its associated value, surrounded by square brackets. You can assign a dictionary literal to a variable or constant or pass it to a function that expects a dictionary.
        
        Hereâ€™s how you would create a dictionary of HTTP response codes and their related messages:
        
        `var responseMessages = [200: "OK",                        403: "Access forbidden",                        404: "File not found",                        500: "Internal server error"]`
        
        TheÂ `responseMessages`Â variable is inferred to have typeÂ `[Int: String]`. TheÂ `Key`Â type of the dictionary isÂ `Int`, and theÂ `Value`Â type of the dictionary isÂ `String`.
        
        To create a dictionary with no key-value pairs, use an empty dictionary literal (`[:]`).
        
        `var emptyDict: [String: String] = [:]`
        
        Any type that conforms to theÂ `Hashable`Â protocol can be used as a dictionaryâ€™sÂ `Key`Â type, including all of Swiftâ€™s basic types. You can use your own custom types as dictionary keys by making them conform to theÂ `Hashable`Â protocol.
        
        # Getting and Setting Dictionary Values
        
        The most common way to access values in a dictionary is to use a key as a subscript. Subscripting with a key takes the following form:
        
        `print(responseMessages[200])// Prints "Optional("OK")"`
        
        Subscripting a dictionary with a key returns an optional value, because a dictionary might not hold a value for the key that you use in the subscript.
        
        The next example uses key-based subscripting of theÂ `responseMessages`Â dictionary with two keys that exist in the dictionary and one that does not.
        
        `let httpResponseCodes = [200, 403, 301]for code in httpResponseCodes {    if let message = responseMessages[code] {        print("Response \(code): \(message)")    } else {        print("Unknown response \(code)")    }}// Prints "Response 200: OK"// Prints "Response 403: Access forbidden"// Prints "Unknown response 301"`
        
        You can also update, modify, or remove keys and values from a dictionary using the key-based subscript. To add a new key-value pair, assign a value to a key that isnâ€™t yet a part of the dictionary.
        
        `responseMessages[301] = "Moved permanently"print(responseMessages[301])// Prints "Optional("Moved permanently")"`
        
        Update an existing value by assigning a new value to a key that already exists in the dictionary. If you assignÂ `nil`Â to an existing key, the key and its associated value are removed. The following example updates the value for theÂ `404`Â code to be simply â€œNot foundâ€ and removes the key-value pair for theÂ `500`Â code entirely.
        
        `responseMessages[404] = "Not found"responseMessages[500] = nilprint(responseMessages)// Prints "[301: "Moved permanently", 200: "OK", 403: "Access forbidden", 404: "Not found"]"`
        
        In a mutableÂ `Dictionary`Â instance, you can modify in place a value that youâ€™ve accessed through a keyed subscript. The code sample below declares a dictionary calledÂ `interestingNumbers`Â with string keys and values that are integer arrays, then sorts each array in-place in descending order.
        
        `var interestingNumbers = ["primes": [2, 3, 5, 7, 11, 13, 17],                          "triangular": [1, 3, 6, 10, 15, 21, 28],                          "hexagonal": [1, 6, 15, 28, 45, 66, 91]]for key in interestingNumbers.keys {    interestingNumbers[key]?.sort(by: >)}
        print(interestingNumbers["primes"]!)// Prints "[17, 13, 11, 7, 5, 3, 2]"`
        
        # Iterating Over the Contents of a Dictionary
        
        Every dictionary is an unordered collection of key-value pairs. You can iterate over a dictionary using aÂ `for`-`in`Â loop, decomposing each key-value pair into the elements of a tuple.
        
        `let imagePaths = ["star": "/glyphs/star.png",                  "portrait": "/images/content/portrait.jpg",                  "spacer": "/images/shared/spacer.gif"]
        for (name, path) in imagePaths {    print("The path to '\(name)' is '\(path)'.")}// Prints "The path to 'star' is '/glyphs/star.png'."// Prints "The path to 'portrait' is '/images/content/portrait.jpg'."// Prints "The path to 'spacer' is '/images/shared/spacer.gif'."`
        
        The order of key-value pairs in a dictionary is stable between mutations but is otherwise unpredictable. If you need an ordered collection of key-value pairs and donâ€™t need the fast key lookup thatÂ `Dictionary`Â provides, see theÂ `KeyValuePairs`Â type for an alternative.
        
        You can search a dictionaryâ€™s contents for a particular value using theÂ `contains(where:)`Â orÂ `firstIndex(where:)`Â methods supplied by default implementation. The following example checks to see ifÂ `imagePaths`Â contains any paths in theÂ `"/glyphs"`Â directory:
        
        `let glyphIndex = imagePaths.firstIndex(where: { $0.value.hasPrefix("/glyphs") })if let index = glyphIndex {    print("The '\(imagePaths[index].key)' image is a glyph.")} else {    print("No glyphs found!")}// Prints "The 'star' image is a glyph.")`
        
        Note that in this example,Â `imagePaths`Â is subscripted using a dictionary index. Unlike the key-based subscript, the index-based subscript returns the corresponding key-value pair as a non-optional tuple.
        
        `print(imagePaths[glyphIndex!])// Prints "(key: "star", value: "/glyphs/star.png")"`
        
        A dictionaryâ€™s indices stay valid across additions to the dictionary as long as the dictionary has enough capacity to store the added values without allocating more buffer. When a dictionary outgrows its buffer, existing indices may be invalidated without any notification.
        
        When you know how many new values youâ€™re adding to a dictionary, use theÂ `init(minimumCapacity:)`Â initializer to allocate the correct amount of buffer.
        
        # Bridging Between Dictionary and NSDictionary
        
        You can bridge betweenÂ `Dictionary`Â andÂ `NSDictionary`Â using theÂ `as`Â operator. For bridging to be possible, theÂ `Key`Â andÂ `Value`Â types of a dictionary must be classes,Â `@objc`Â protocols, or types that bridge to Foundation types.
        
        Bridging fromÂ `Dictionary`Â toÂ `NSDictionary`Â always takes O(1) time and space. When the dictionaryâ€™sÂ `Key`Â andÂ `Value`Â types are neither classes norÂ `@objc`Â protocols, any required bridging of elements occurs at the first access of each element. For this reason, the first operation that uses the contents of the dictionary may take O(*n*).
        
        Bridging fromÂ `NSDictionary`Â toÂ `Dictionary`Â first calls theÂ `copy(with:)`Â method (`- copyWithZone:`Â in Objective-C) on the dictionary to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances ofÂ `NSDictionary`Â that are already immutable,Â `copy(with:)`Â usually returns the same dictionary in O(1) time; otherwise, the copying performance is unspecified. The instances ofÂ `NSDictionary`Â andÂ `Dictionary`Â share buffer using the same copy-on-write optimization that is used when two instances ofÂ `Dictionary`Â share buffer.
        
- completion
    
    **nstance Property
    completion**
    
    The completion which will be sent to aÂ `Subscriber`.
    
    iOS 13.0+iPadOS 13.0+macOS 10.15+Mac Catalyst 13.0+tvOS 13.0+watchOS 6.0+
    
    ## **Declaration**
    
    `var completion: [Subscribers](https://developer.apple.com/documentation/combine/subscribers).[Completion](https://developer.apple.com/documentation/combine/subscribers/completion)<Failure> { get }`
    

## ğŸ“¢Â 8ì£¼ì°¨ ìˆ˜ì—… í›„ê¸°

---

- ì• ë‹ˆë©”ì´ì…˜ì€ ì•±ì„ ë§Œë“¤ ë•Œ ì•±ì˜ ì»¨ì…‰ì— ë”°ë¼ ì—„ì²­ë‚˜ê²Œ í•„ìš”í•˜ê²Œ ë˜ëŠ” í…Œí¬ë¼ê³  ìƒê°ì„ í•œë‹¤.

   ì»´í¬ë„ŒíŠ¸ê°€ ë‚´ ì˜ì§€ëŒ€ë¡œ ì›€ì§ì´ëŠ” ê²ƒì„ ë³´ë©° ìƒë‹¹íˆ ì¬ë¯¸ìˆì—ˆë‹¤.

## âš ï¸Â ìŠ¤í„°ë””ê°„ ì£¼ì˜ì‚¬í•­

---

1. **ê³¼ì œ í”¼ë“œë°± ê¸°ë°˜ ì§„í–‰ì…ë‹ˆë‹¤** - í•œëª…ì”© ë³¸ì¸ì˜ **ê³¼ì œë¥¼ ë°œí‘œ**í•˜ëŠ” ì‹œê°„ ê·¸ë¦¬ê³  í•´ì˜¨ **ê³¼ì œì— ëŒ€í•œ í”¼ë“œë°±**ì„ í•˜ëŠ” ì‹œê°„ (ex:ì „ ì´ë ‡ê²Œ ìƒê°í•´ì„œ ì´ëŸ° ë¶€ë¶„ ë‹¤ë¥´ê²Œ í•´ì™”ëŠ”ë° ì €ê²ƒë„ ê´œì°®ì€ ê²ƒ ê°™ì•„ìš”!)ì´ **ë¬´ì¡°ê±´ ê¸°ë°˜**ì´ ë˜ì–´ì•¼ í•©ë‹ˆë‹¤!
2. ë¶€ê°€ì ìœ¼ë¡œ **ì›Œí¬ë¶ì—ì„œ ì œê³µë˜ëŠ” í‚¤ì›Œë“œ í˜¹ì€ ê°•ì˜ì—ì„œ ë“¤ì€ ë””í…Œì¼ì ì¸ ë¶€ë¶„**ì—ì„œ ë” í† ì˜í•´ë´ë„ ì¢‹ì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤.

## âœ…Â ì‹¤ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

---

- [x]  UIViewì˜ animate ë©”ì†Œë“œë¥¼ í™œìš©í•˜ì—¬ ì• ë‹ˆë©”ì´ì…˜ì„ êµ¬í˜„í–ˆë‚˜ìš”?
    
    <img width="1146" alt="6" src="https://user-images.githubusercontent.com/102133961/207801530-0e1895da-ff0c-4f34-96fa-635707658a1f.png">


- [x]  layoutIfNeeded ë©”ì†Œë“œë¥¼ í™œìš©í•˜ì—¬ ì• ë‹ˆë©”ì´ì…˜ì„ êµ¬í˜„í–ˆë‚˜ìš”?
    
    <img width="1146" alt="6" src="https://user-images.githubusercontent.com/102133961/207801538-0ca449c7-f3fb-4f0f-aa2b-80f6677c01f2.png">


- [x]  Tap Gestureë¥¼ í™œìš©í•˜ì—¬ ì• ë‹ˆë©”ì´ì…˜ì„ êµ¬í˜„í–ˆë‚˜ìš”?
    
    <img width="1146" alt="6" src="https://user-images.githubusercontent.com/102133961/207801546-d6a57a98-f084-4107-9b26-be1dd315c420.png">


- ë¯¸ì…˜ ì°¸ê³  ì˜ìƒ
    
    [[iOS] #8. Animation - Practice](https://www.youtube.com/watch?v=_HZs9sVhyyY&list=PLKi37YIxs-7taJns3l65dDOKjgsN1upi9)
    

## âš¡ íŠ¸ëŸ¬ë¸” ìŠˆíŒ…

---

<aside>
ğŸ’¡ ì‹¤ìŠµì´ë‚˜ ë¯¸ì…˜ì„ í•˜ë©´ì„œ ìƒê¸´ ë¬¸ì œë“¤ì— ëŒ€í•´ì„œ, **ì´ìŠˆ - ë¬¸ì œ - í•´ê²°** ìˆœì„œë¡œ ì‘ì„±í•´ì£¼ì„¸ìš”.

</aside>

- âš¡ì´ìŠˆ No.1 (ì˜ˆì‹œ, ì„œì‹ë§Œ ë³µì‚¬í•˜ì‹œê³  ì§€ì›Œì£¼ì„¸ìš”.)
    
    **`ì´ìŠˆ`**
    
    ğŸ‘‰ ì•± ì‹¤í–‰ ì¤‘ì— ë…¸ë˜ ë‹¤ìŒ ë²„íŠ¼ì„ ëˆ„ë¥´ë‹ˆê¹Œ ì•±ì´ ì¢…ë£Œë˜ì—ˆë‹¤.
    
    **`ë¬¸ì œ`**
    
    ğŸ‘‰ ë…¸ë˜í´ë˜ìŠ¤ì˜ ë°ì´í„°ë¦¬ìŠ¤íŠ¸ì˜ Sizeë¥¼ ë„˜ì–´ì„œ NullPointExceptionì´ ë°œìƒí•˜ì—¬ ì•±ì´ ì¢…ë£Œëœ ê²ƒì´ì—ˆë‹¤. 
    
    **`í•´ê²°`**
    
    ğŸ‘‰  ë…¸ë˜ ë‹¤ìŒ ë²„íŠ¼ì„ ëˆŒë €ì„ ë•Œ ë°ì´í„°ë¦¬ìŠ¤íŠ¸ì˜ Sizeë¥¼ ê²€ì‚¬í•´ Sizeë³´ë‹¤ ë„˜ì–´ê°€ë ¤ê³  í•˜ë©´ ë‹¤ìŒìœ¼ë¡œ ë„˜ì–´ê°€ëŠ” ë©”ì„œë“œë¥¼ ì‹¤í–‰ì‹œí‚¤ì§€ ì•Šê³ , ì²« ë…¸ë˜ë¡œ ëŒì•„ê°€ê²Œë” í•´ê²°
    
    **`ì°¸ê³  ë ˆí¼ëŸ°ìŠ¤`**
    
    - ë§í¬

## ğŸ¤”Â ì´ê²ƒë„ í•œ ë²ˆ ìƒê°í•´ë´ìš”!

---

- UIView.animateì˜ optionsì—ëŠ” ì–´ë–¤ ì¢…ë¥˜ë“¤ì´ ìˆì„ì§€ ê³µë¶€í•´ë³´ì„¸ìš”!
    
    
- Core Animationì— ëŒ€í•´ ê³µë¶€í•´ë³´ì„¸ìš”!
    
    
- Gesture ì—¬ëŸ¬ê°œê°€ ê²¹ì¹˜ë©´ ì–´ë–»ê²Œ ë ì§€ ê³µë¶€í•´ë³´ì„¸ìš”!
    
    
- Gestureì˜ ì¢…ë¥˜ì— ëŒ€í•´ ê³µë¶€í•´ë³´ì„¸ìš”! (ex. Tap Gesture, Swipe Gesture ë“±)
    
    
- #selectorì— ëŒ€í•´ì„œ ê³µë¶€í•´ë³´ì„¸ìš”!

## ìŠ¤íƒ ë‹¤ë“œ ë¯¸ì…˜
ì˜¤ëŠ˜ í•  ë¯¸ì…˜ì€ ë‚´ í”„ë¡œì íŠ¸ì— ì• ë‹ˆë©”ì´ì…˜ ì ìš©í•˜ê¸°

ì €ë²ˆì— ë½€ëª¨ë„ë¡œì—ì„œ ì´ë¯¸ ì• ë‹ˆë©”ì´ì…˜ì„ ì‚¬ìš©í•œ ë°”ê°€ ìˆê¸° ë•Œë¬¸ì—

ì˜¤ëŠ˜ì€ ì• ë‹ˆë©”ì´ì…˜ì„ í•˜ë‚˜ ë” ì¶”ê°€í•´ë³´ëŠ” ë°©ì‹ìœ¼ë¡œ ì§„í–‰í•˜ê³ ì í•œë‹¤.

ì €ë²ˆ ì½”ë“œì—ì„œ ì• ë‹ˆë©”ì´ì…˜ê³¼ ê´€ë ¨ë˜ì—ˆë˜ ë¶€ë¶„ì€ 

```swift

    
    ***@IBOutlet weak var imageView: UIImageView!***
   
    

    
    func configureToggleButton(){
        self.toggleButton.setTitle("ì‹œì‘", for: .normal)
        self.toggleButton.setTitle("ì¼ì‹œì •ì§€", for: .selected)
    }
    
    func startTimer() {
        if self.timer == nil {
            self.timer = DispatchSource.makeTimerSource(flags: [], queue: .main)
            self.timer?.schedule(deadline: .now(), repeating: 1)
            self.timer?.setEventHandler(handler: { [weak self] in
                guard let self = self else { return }
                self.currentSeconds -= 1
                let hour = self.currentSeconds / 3600
                let minute = (self.currentSeconds % 3600) / 60
                let seconds = (self.currentSeconds % 3600) % 60
                self.timerLabel.text = String(format: "%02d:%02d:%02d", hour, minute, seconds)
                self.progessView.progress = Float(self.currentSeconds) / Float(self.duration)
                **UIView.animate(withDuration: 0.5, delay: 0, animations: {
                    self.imageView.transform = CGAffineTransform(rotationAngle: .pi)
                    
                })
                UIView.animate(withDuration: 0.5, delay: 0.5, animations: {
                    self.imageView.transform = CGAffineTransform(rotationAngle: .pi * 2)
                    
                })**
                if self.currentSeconds <= 0 {
                    
                    self.stopTimer()
                    AudioServicesPlaySystemSound(1005) 
                }
                
            })
            self.timer?.resume()
        }
        
        
    }
    
    func stopTimer(){
        if self.timerStatus == .pause {
            self.timer?.resume()
        }
        self.timerStatus = .end
        self.cancelButton.isEnabled = false
        UIView.animate(withDuration: 0.5, animations: {
            self.timerLabel.alpha = 0
            self.progessView.alpha = 0
            self.datePicker.alpha = 1
            ***self.imageView.transform = .identity***
        })
        self.toggleButton.isSelected = false
        self.timer?.cancel()
        self.timer = nil
        
        
    }
    
    @IBAction func tapCancelButton(_ sender: UIButton) {
        switch self.timerStatus {
        case .start, .pause:
            self.stopTimer()
        default:
            break
            
        }
    }
    
    @IBAction func tapToggleButton(_ sender: UIButton) {
        self.duration = Int(self.datePicker.countDownDuration)
        self.clockRecord.append(String(self.duration))
        UserDefaults.standard.set(self.clockRecord, forKey: "clockRecord")
        switch self.timerStatus {
        case .end:
            self.currentSeconds = self.duration
            self.timerStatus = .start
            ***UIView.animate(withDuration: 0.5, animations: {
                self.timerLabel.alpha = 1
                self.progessView.alpha = 1
                self.datePicker.alpha = 0
                
            })***
            self.toggleButton.isSelected = true
            self.cancelButton.isEnabled = true
            self.startTimer()
            
        case .start:
            self.timerStatus = .pause
            self.toggleButton.isSelected = false
            self.timer?.suspend()
            
        case .pause:
            self.timerStatus = .start
            self.toggleButton.isSelected =  true
            self.timer?.resume()
    
            
            
        }
    }
    
    
} 
```

ì´ ë¶€ë¶„ë“¤, ë‚´ê°€ ì›í•˜ëŠ” ë°©ì‹ì€ ë‚´ ì•± ë©”ì¸ í™”ë©´ì˜ ì•„ë˜ì— ìœ„ì¹˜í•œ ê¼¬ë§¹ì´ ì‚¬ì§„ì´

ìŠ¤íƒ€íŠ¸ ë²„íŠ¼ì„ ëˆ„ë¥´ì ë§ˆì, (ì´ ê²½ìš° datepicker ê°€ ì—†ì–´ì§€ë¯€ë¡œ) ë„“ì–´ì§„ ê³µê°„ì„ ì±„ìš°ê¸° ìœ„í•´ í¬ê¸°ë¥¼ í‚¤ìš°ëŠ” ê²ƒì´ë‹¤.

ë”°ë¼ì„œ ì½”ë“œë¥¼ ì´ëŸ° ì‹ìœ¼ë¡œ ì¶”ê°€í•´ì¤€ë‹¤.

```swift
import UIKit
import AudioToolbox

enum TimerStatus {
    case start
    case pause
    case end
}

class ViewController: UIViewController {

    
    @IBOutlet weak var timerLabel: UILabel!
    @IBOutlet weak var progessView: UIProgressView!
    @IBOutlet weak var datePicker: UIDatePicker!
    
    @IBOutlet weak var cancelButton: UIButton!
    @IBOutlet weak var toggleButton: UIButton!
    
    @IBOutlet weak var imageView: UIImageView!
    
    @IBOutlet weak var StudyView: UIImageView!
    
    
    var duration = 60
    var timerStatus: TimerStatus = .end
    var timer: DispatchSourceTimer?
    var currentSeconds = 0
    
    
    var clockRecord: [String] = []
    
    override func viewDidLoad() {
        
        super.viewDidLoad()
        self.configureToggleButton()

  
    }
    

    func setTimerInfoViewVisible(isHidden: Bool){
        self.timerLabel.isHidden = isHidden
        self.progessView.isHidden = isHidden
        
    }
    
    func configureToggleButton(){
        self.toggleButton.setTitle("ì‹œì‘", for: .normal)
        self.toggleButton.setTitle("ì¼ì‹œì •ì§€", for: .selected)
    }
    
    func startTimer() {
        if self.timer == nil {
            self.timer = DispatchSource.makeTimerSource(flags: [], queue: .main)
            self.timer?.schedule(deadline: .now(), repeating: 1)
            self.timer?.setEventHandler(handler: { [weak self] in
                guard let self = self else { return }
                self.currentSeconds -= 1
                let hour = self.currentSeconds / 3600
                let minute = (self.currentSeconds % 3600) / 60
                let seconds = (self.currentSeconds % 3600) % 60
                self.timerLabel.text = String(format: "%02d:%02d:%02d", hour, minute, seconds)
                self.progessView.progress = Float(self.currentSeconds) / Float(self.duration)
                UIView.animate(withDuration: 0.5, delay: 0, animations: {
                    self.imageView.transform = CGAffineTransform(rotationAngle: .pi)
                    self.StudyView.transform = CGAffineTransform(scaleX: 2.0, y: 2.0)
                })
                UIView.animate(withDuration: 0.5, delay: 0.5, animations: {
                    self.imageView.transform = CGAffineTransform(rotationAngle: .pi * 2)
                    
                })
                if self.currentSeconds <= 0 {
                    
                    self.stopTimer()
                    AudioServicesPlaySystemSound(1005) 
                }
                
            })
            self.timer?.resume()
        }
        
        
    }
    
    func stopTimer(){
        if self.timerStatus == .pause {
            self.timer?.resume()
        }
        self.timerStatus = .end
        self.cancelButton.isEnabled = false
        UIView.animate(withDuration: 0.5, animations: {
            self.timerLabel.alpha = 0
            self.progessView.alpha = 0
            self.datePicker.alpha = 1
            self.imageView.transform = .identity
            self.StudyView.transform = .identity
        })
        self.toggleButton.isSelected = false
        self.timer?.cancel()
        self.timer = nil
        
        
    }
    
    @IBAction func tapCancelButton(_ sender: UIButton) {
        switch self.timerStatus {
        case .start, .pause:
            self.stopTimer()
        default:
            break
            
        }
    }
    
    @IBAction func tapToggleButton(_ sender: UIButton) {
        self.duration = Int(self.datePicker.countDownDuration)
        self.clockRecord.append(String(self.duration))
        UserDefaults.standard.set(self.clockRecord, forKey: "clockRecord")
        switch self.timerStatus {
        case .end:
            self.currentSeconds = self.duration
            self.timerStatus = .start
            UIView.animate(withDuration: 0.5, animations: {
                self.timerLabel.alpha = 1
                self.progessView.alpha = 1
                self.datePicker.alpha = 0
                
            })
            self.toggleButton.isSelected = true
            self.cancelButton.isEnabled = true
            self.startTimer()
            
        case .start:
            self.timerStatus = .pause
            self.toggleButton.isSelected = false
            self.timer?.suspend()
            
        case .pause:
            self.timerStatus = .start
            self.toggleButton.isSelected =  true
            self.timer?.resume()
    
            
            
        }
    }
    
    
}
```

í† ê¸€ ë²„íŠ¼ì„ ëˆ„ë¥¼ ë•Œ, ë©ˆì¶œ ë•Œ ìƒˆë¡œìš´ ì½”ë“œê°€ ë“¤ì–´ê°”ê³ 

íŠ¹íˆ StartTimer() í•¨ìˆ˜ í•¸ë“¤ëŸ¬ì—ì„œ í¬ê¸°ê°€ ë‘ ë°°ë¡œ ëŠ˜ì–´ë‚˜ëŠ” ì§ì ‘ì ì¸ í•¨ìˆ˜ê°€ ì¶”ê°€ëœ ê²ƒì´ ë³´ì¼ ê²ƒì´ë‹¤.


https://user-images.githubusercontent.com/102133961/207801682-db4cda81-bea9-467d-ab6b-cf95e7aa9c25.mov

